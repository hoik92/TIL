# List

## 리스트

* 순서를 가진 데이터의 집합을 가리키는 추상자료형(abstract data type)
* 동일한 데이터를 가지고 있어도 상관없다.
* 순차 리스트 : 배열을 기반으로 구현된 리스트
* 연결 리스트 : 메모리의 동적할당을 기반으로 구현된 리스트

### 1. 리스트 주요 함수

* addtoFirst() : 리스트의 앞쪽에 원소를 추가
* addtoLast() : 리스트의 뒤쪽에 원소를 추가
* add() : 리스트의 특정 위치에 원소룰 추가
* delete() : 리스트의 특정 위치에 있는 원소를 삭제
* get() : 리스트의 특정 위치에 있는 원소를 리턴

### 2. 순차 리스트

* 구현 방법
  * 1차원 배열에 항목들을 순서대로 저장한다.
  * 데이터의 종류와 구조에 따라 구조화된 자료구조를 만들어 배열로 만들 수도 있다.
* 데이터 접근
  * 배열의 인덱스를 이용한다.
* 삽입 연산
  * 삽입 위치 다음의 항목들을 이동해야 한다.
* 삭제 연산
  * 삭제 위치 다음의 항목들을 이동해야 한다.
* 순차 리스트의 문제점
  * 자료의 삽입/삭제 연산 과정에서 연속적인 메모리 배열을 위해 원소들을 이동시키는 작업이 필요하다.
  * 원소의 개수가 많고 삽입/삭제 연산이 빈번하게 일어날 수록 직업에 소요되는 시간이 크게 증가한다.
  * 배열의 크기가 정해진 경우, 실제 메모리보다 크게 할당하여 메모리 낭비를 초래할 수도 있고, 반대로 메모리가 부족할 수도 있다.

### 3. 연결 리스트(Linked List)

1. 특성

* 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 원소의 주소를 연결하여 하나의 전체적인 자료구조를 이룬다.
* 링크를 통해 원소에 접근하므로, 순차 리스트에서처럼 물리적인 순서를 맞추기 위한 작업이 필요하지 않다.
* 자료구조의 크기를 동적으로 조정할 수 있어 메모리의 효율적인 사용이 가능하다.

2. 노드

* 연결 리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료단위
* 구성 요소
  * 데이터 필드 : 원소의 값을 저장하느 자료구조
  * 링크 필드 : 다음 노드의 주소를 저정하는 자료구조

3. 헤드

* 리스트의 처음 노드를 가리키는 레퍼런스

### 4. 단순 연결 리스트(Singly Linked List)

1. 연결 구조

* 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조를 가진다.
* 헤드가 가장 앞의 노드를 가리키고, 링크 필드가 연속적으로 다음 노드를 가리킨다.
* 최종적으로 NULL을 가리키는 노드가 리스트의 가장 마지막 노드이다.

2. 삽입 연산

* 메모리를 할당하여 새로운 노드 `new` 생성
* 새로운 노드 `new`의 데이터 필드에 `B` 저장
* 삽입될 위치의 바로 앞에 위치한 노드의 링크 필드를 `new`에 복사
* `new`의 주소를 앞 노드의 링크 필드에 저장

3. 삭제 연산

* 삭제할 노드의 앞 노드(선행 노드) 탐색
* 삭제할 노드의 링크 필드를 선행 노드의 링크 필드에 복사

### 5. 이중 연결 리스트(Doubly Linked List)

1. 특성

* 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
* 두개의 링크 필드와 한 개의 데이터 필드로 구성

2. 삽입 연산

* 메모리를 할당하여 새로운 노드 `new` 생성
* 새로운 노드 `new`의 데이터 필드에 `D` 저장
* 삽입될 위치의 바로 앞에 위치한 노드의 `next`를 `new`의 `next`에 저장
* `new`의 주소를 바로 앞 노드의 `next`에 저장
* `new`의 `prev`에 바로 앞 노드의 주소를 저장
* `new`의 다음 노드의 `prev`에 `new`의 주소를 저장

3. 삭제 연산

* 삭제할 노드 `cur`의 다음 노드의 주소를 `cur`의 바로 앞 노드의 `next`에 저장
* `cur`의 바로 앞 노드의 주소를 `cur`의 다음 노드의 `prev`에 저장
* `cur`이 가리키는 노드에 할당된 메모리를 반환



## 삽입 정렬(Insertion Sort)

* 도서관 사서가 책을 정렬할 때, 일반적으로 활용되는 방식
* 자료 배열의 모든 원소들을 앞에서부터 차례대로 이미 정렬된 부분과 비교하여 자신의 위치를 찾아냄으로써 정렬을 완성한다.

* 정렬 과정
  * 정렬할 자료를 두개의 부분집합 S와 U로 가정
    * S : 정렬된 앞부분의 원소들
    * U : 아직 정렬되지 않은 나머지 원소들
  * 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내어 이미 정렬되어있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입한다.
  * 삽입 정렬을 반복하면서 부분집합 S의 원소는 하나씩 늘리고 부분집합 U의 원소는 하나씩 감소하게 한다. 
  * 부분집합 U가 공집합이 되면 삽입정렬이 완성된다.
* 시간 복잡도 : O(n^2)



## 병합 정렬(Merge Sort)

* 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
* 분할 정복 알고리즘 활용
  * 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
  * top-down 방식
* 시간 복잡도 : O(n log n)



## 연결 리스트를 이용한 스택

* 스택의 원소 : 리스트의 노드
  * 스택 내의 순서는 리스트의 링크를 통해 연결됨
  * push : 리스트의 마지막에 노드 삽입
  * pop : 리스트의 마지막 노드 반환/삭제
* 변수 top : 리스트의 마지막 노드를 가리키는 변수
  * 초기 상태 : top = null



## Revisit to 우선수위 큐

* 우선순위 큐의 구현
  * 배열을 이용한 우선순위 큐
  * 리스트를 이용한 이선순위 큐
* 우선순위 큐의 기본 연산
  * 삽입 : enQueue
  * 삭제 : deQueue
* 배열을 이용한 우선순위 큐 구현
  * 배열을 이용하여 자료 저장
  * 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
  * 가장 앞에 최고 우선순위의 원소가 위치하게 됨
  * 문제점
    * 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생함
    * 이에 소요되는 시간이나 메모리 낭비가 큼
* 리스트를 이용한 우선순위 큐 구현
  * 연결 리스트를 이용하여 자료 저장
  * 원소를 삽입하는 과정에서 리스트 내 노드의 원소들과 비교하여 적절한 위치에 노드를 삽입하는 구조
  * 리스트의 가장 앞쪽에 최고 우선순위가 위치하게 됨
  * 배열 대비 장점
    * 삽입/삭제 연산 이후 원소의 재배치가 필요 없음
    * 메모리의 효율적인 사용이 가능함