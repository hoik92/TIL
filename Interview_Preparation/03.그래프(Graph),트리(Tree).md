# 03. 그래프(Graph), 트리(Tree)

## 1. 그래프(Graph)

> 단순히 노드(node)와 그 노드를 연결하는 간선(edge)을 모아놓은 자료구조
>
> 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조(지하철 노선도 등,,)

용어

* 정점(vertex): 위치의 개념(node)
* 간선(edge): 위치 간의 관계, 노드 사이를 연결하는 선
* 인접 정점(adjacent vertex): 간선에 의해 직접 연결된 정점
* 정점의 차수(degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수
  * 무방향 그래프에 존재하는 정점의 모든 차수의 합 = 그래프 간선의 수 * 2
* 진입 차수(in-degree): 방향 그래프에서 외부에서 연결되어 오는 간선의 수(내차수)
* 진출 차수(out-degree): 방향 그래프에서 외부로 향하는 간선의 수(외차수)
  * 방향 그래프에 있는 진입 차수의 합 = 진출 차수의 합 = 그래프 간선의 수(외차수 + 내차수)
* 경로 길이(path length): 경로를 구성하는 데 사용된 간선의 수
* 단순 경로(simple path): 경로 중에서 반복되는 정점이 없는 경우
* 사이클(cycle): 단순 경로의 시작 정점과 종료 정점이 동일한 경우

특징

* 그래프는 네트워크 모델이다.
* 2개 이상의 경로가 가능하다.
  * 즉, 노드들 사이에 무방향/방향에서 양방향 경로를 가질 수 있다.
* self-loop뿐 아니라 loop/circuit 모두 가능하다.
* 루트 노드라는 개념이 없다.
* 부모-자식 관계라는 개념이 없다.
* 순회는 BFS나 DFS로 이루어진다.
* 그래프는 순환(Cyclic) 혹은 비순환(Acyclic)이다.
* 그래프는 크게 방향 그래프와 무방향 그래프가 있다.
* 간선의 유무는 그래프에 따라 다르다.

종류

* 무방향 그래프(Undirected Graph)
  * 무방향 그래프의 간선은 양 방향으로 갈 수 있다.
  * 정점 A와 B를 연결하는 간선은 (A, B)와 같이 정점의 쌍으로 표현한다. (A, B) = (B, A)
* 방향 그래프(Directed Graph)
  * 방향 그래프의 간선은 방향성이 존재한다.
  * A => B로 연결된 간선은 <A, B>로 표시한다. <A, B> != <B, A>

* 가중치 그래프(Weighted Graph)
  * 간선에 비용이나 가중치가 할당된 그래프
  * **네트워크**라고도 한다.
* 연결 그래프(Connected Graph)
  * 무방향 그래프에 있는 모든 정점쌍에 대해 항상 경로가 존재하는 경우
* 비연결 그래프(Disconnected Graph)
  * 무방향 그래프에서 특정 정점쌍에 대한 경로가 존재하지 않는 경우
* 순환 그래프(Cyclic Graph)
  * 단순 경로의 시작 정점과 종료 정점이 동일한 경우
* 비순환 그래프(Acyclic Graph)
  * 사이클이 없는 그래프
* 완전 그래프(Complete Graph)
  * 그래프에 속해 있는 모든 정점이 서로 직접 연결되어 있는 그래프
  * 무방향 완전 그래프의 경우 정점의 수가 n개이면 간선의 수 = n(n-1)/2



### 그래프의 구현

인접 리스트(Adjacency List)

* 리스트의 인덱스를 정점으로 하고 해당 정점으로부터 직접 연결된 정점의 정보(인덱스)를 원소로 가지게 한다.
* 무방향 그래프에서 간선은 두 번 저장된다.
  * (a, b) 간선의 경우 a 정점에서 연결된 b 정점을 저장하고 b 정점에서 연결된 a 정점을 저장한다.

인접 행렬(Adjacency Matrix)

* 정점의 개수가 n개 이면 n*n의 Boolean Matrix로 표현한다.
* `matrix[i][j] = true`이면 i => j로 연결된 간선이 존재한다는 의미이다.
* `true`, `false` 대신 `1`, `0`으로 표현하는 정수 행렬로도 가능하다.
* 메모리는 간선의 개수와 상관없이 정점의 개수 n에 의존하며 항상 n*n개의 메모리 공간이 필요하다.
* 무방향 그래프의 경우 인접 행렬은 대칭 행렬(Symmetric Matrix)이 된다.
* 간선의 개수가 적은 경우 인접 리스트보다 비효율적이다.



### 그래프의 탐색

깊이 우선 탐색(DFS, Depth First Search)

* 넓게 탐색하기 전에 깊게 탐색한다.
* 모든 노드를 방문하고자 하는 경우 주로 선택한다.
* 임의의 정점에서 가능한 깊이(멀리) 탐색한 후 다음 분기로 넘어간다.

너비 우선 탐색(BFS, Breadth First Search)

* 깊게 탐색하기 전에 넓게 탐색한다.
* 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고자 하는 경우 선택한다.
* 임의의 정점에서 인접한 모든 노드를 탐색한 후 다음 분기로 넘어간다.



## 2. 트리(Tree)

> 그래프의 일종으로 계층적 관계를 표현하는 자료구조
>
> 최상위 계층에 루트 노드가 존재하며 0개 이상의 자식 노드를 가지고 있다.

용어

- 루트 노드(root node): 부모가 없는 노드, 하나의 트리는 하나의 루트 노드를 가진다.
- 단말 노드(leaf node): 자식이 없는 노드, 말단 노드
- 내부 노드(internal node): 단말 노드가 아닌 노드
- 간선(edge): 노드를 연결하는 선
- 형제(sibling): 같은 부모를 가지는 노드
- 노드의 크기(size): 자신을 포함한 모든 자손 노드의 수
- 노드의 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
- 노드의 레벨(level): 트리의 특정 깊이를 가지는 노드의 집합
- 노드의 차수(degree): 하위 트리 개수 / 간선 수 = 각 노드가 지닌 가지의 수
- 트리의 차수(degree of tree): 트리의 최대 차수
- 트리의 높이(height): 루트노드에서 가장 멀리 있는 노드의 깊이

특징

- 트리는 DAG(Directed Acyclic Graphs, 방향성이 있는 비순환 그래프)의 한 종류이다.
- 노드가 n개인 트리는 항상 n-1개의 간선을 가진다.
- 루트 노드에서 임의의 한 노드로 가는 경로는 하나이다.
- 루트 노드는 한 개만 존재하며 모든 자식 노드는 하나의 부모 노드만을 가진다.
- 순회는 pre-order, in-order, post-order로 이루어진다.
- 이진 트리, 이진 탐색 트리, 균형 트리(AVL 트리, red-black 트리), 이진 힙(최대힙, 최소힙) 등이 있다.

종류

- 이진 트리(Binary Tree)

  - 각 노드는 최대 두개의 자식을 가진다.

  ```c++
  // pre-order(전위 순회)
  void preOrderTraversal(Node node) {
      if(node != null) {
          visit(node);
          preOrderTraversal(node.left);
          preOrderTraversal(node.right);
      }
  }
  // in-order(중위 순회)
  void inOrderTraversal(Node node) {
      if(node != null) {
          inOrderTraversal(node.left);
          visit(node);
          inOrderTraversal(node.right);
      }
  }
  // post-order(후위 순회)
  void postOrderTraversal(Node node) {
      if(node != null) {
          postOrderTraversal(node.left);
          postOrderTraversal(node.right);
          visit(node);
      }
  }
  ```

- 이진 탐색 트리(Binary Search Tree)

  - 모든 노드가 왼쪽 자식 노드 <= 현재 노드 <= 오른쪽 자식 노드 를 만족하는 이진 트리

- 균형 트리

  - O(logn) 시간에 insert와 find를 할 수 있을 정도로 균형이 잡힌 트리
  - 레드-블랙 트리, AVL 트리

- 완전 이진 트리(Complete Binary Tree)

  - 트리의 모든 높이에서 노드가 꽉 차있는 이진 트리. 즉, 마지막 레벨을 제외하고 모든 레벨이 꽉 차있다.
  - 마지막 레벨은 꽉 차있지 않아도 되지만 노드가 왼쪽부터 오른쪽으로 채워져야 한다.
  - 완전 이진 트리는 배열을 사용해 효율적으로 표현 가능하다.

- 전 이진 트리(Full Binary Tree, Strictly Binary Tree)

  - 모든 노드가 0개 또는 2개의 자식 노드를 가지는 이진 트리

- 포화 이진 트리(Perfect Binary Tree)

  - 전 이진 트리이면서 완전 이진 트리인 경우
  - 모든 말단 노드는 같은 높이에 있어야 한다.
  - 모든 내부 노드가 2개의 자식 노드를 가진다.
  - 노드의 개수는 2^k-1개이다.

- 최소힙(Min Heap)

  - 완전 이진 트리의 형태이며 각 노드의 값이 자식 노드의 값보다 작다.
  - 따라서 루트 노드의 값은 해당 트리에서 최소값이다.
  - n개의 노드로 힙을 구성하는 경우 높이는 logn이다.

- 최대힙(Max Heap)

  - 각 노드의 값이 자식 노드의 값보다 크다.
  - 따라서 루트 노드의 값은 해당 트리에서 최대값이다.