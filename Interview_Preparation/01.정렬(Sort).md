# 01. 정렬(Sort)

n개의 숫자가 입력으로 주어졌을 때, 이를 사용자가 지정한 기준에 맞게 정렬하는 알고리즘

## 1. 선택 정렬(Selection Sort)

> 현재 위치에 들어갈 값을 찾아 정렬하는 방법

1. 정렬되지 않은 인덱스의 맨 앞에서부터 이를 포함한 그 이후의 배열값 중 가장 작은 값을 찾는다.
2. 가장 작은 값을 찾으면 그 값을 현재 인덱스의 값과 바꾼다.
3. 다음 인덱스에서 위 과정을 반복한다.



이 정렬 알고리즘은 n-1개, n-2개, ..., 1개씩 비교를 반복한다.

배열이 어떻게 되어있든지 전체 비교를 진행하므로 시간 복잡도는 **O(n^2)**이다.

단 하나의 배열에서 진행하므로 공간 복잡도는 O(n)이다.

```c++
void selectionSort(vector<int> v) {
    for(int i=0; i<v.size()-1; i++) {
        int tmp = i;
        for(int j=i+1; j<v.size(); j++) {
            if(v[tmp] >= v[j]) tmp = j;
        }
        swap(v[i], v[tmp]);
    }
}
```



## 2. 삽입 정렬(Insertion Sort)

> 현재의 위치에서 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아 삽입하는 방법

1. 두 번째 인덱스에서 시작한다. 현재 인덱스를 별도로 저장하고 비교 인덱스를 현재 인덱스 -1로 한다.
2. 별도로 저장한 삽입 변수와 비교 인덱스의 값을 비교한다.
3. 삽입 변수의 값이 작으면 현재 인덱스 값을 비교 인덱스 값으로 변경하고 비교 인덱스를 -1 하여 반복한다.
4. 삽입 변수의 값이 크면 비교 인덱스 +1에 삽입 변수를 저장한다.



이 정렬 알고리즘은 최악의 경우(역으로 정렬된 경우) n-1개, n-2개, ..., 1개씩 비교를 반복한다.

따라서 최악의 경우에 시간 복잡도는 **O(n^2)**이다.

이미 정렬되어 있는 경우에는 한 번씩 비교하므로 시간 복잡도는 **O(n)**이다.

단 하나의 배열에서 진행하므로 공간 복잡도는 O(n)이다.

```c++
void insertionSort(vector<int> v) {
    for(int i=1; i<v.size(); i++) {
        int key = v[i], j = i-1;
        while(j>=0 && key<v[j]) {
           	v[j+1] = v[j];
            j--;
        }
        v[j+1] = key;
    }
}
```



## 3. 버블 정렬(Bubble Sort)

> 연속된 두 개의 인덱스의 값을 비교하여 기준에 따라 위치를 바꾸어 정렬하는 방법

1. 현재 인덱스의 값과 바로 다음 인덱스의 값을 비교한다.
2. 현재 인덱스가 크면 다음 인덱스와 값을 바꾼다.
3. 다음 인덱스가 크면 바꾸지 않는다.
4. 이를 (전체 배열의 크기 - 현재까지 순환한 바퀴 수) 만큼 반복한다.



이 정렬 알고리즘은 n-1개, n-2개, ..., 1개씩 비교를 반복한다.

배열이 어떻게 되어있든지 전체 비교를 진행하므로 시간 복잡도는 **O(n^2)**이다.

단 하나의 배열에서 진행하므로 공간 복잡도는 O(n)이다.

```c++
void bubbleSort(vector<int> v) {
    for(int i=0; i<v.size()-1; i++) {
        for(int j=0; j<v.size()-1-i; j++) {
            if(v[j] > v[j+1]) {
                swap(v[j], v[j+1]);
            }
        }
    }
}
```



## 4. 병합 정렬(Merge Sort)

> 분할 정복(Divide and Conquer)방식의 알고리즘
>
> 큰 문제를 반으로 쪼개 작게 만들어 문제를 해결해나가는 방식으로 배열의 크기가 1보다 작거나 같을 때까지 분할을 반복한다.

분할

1. 현재 배열을 반으로 쪼갠다. 배열의 시작과 종료 위치를 더한 후 2로 나누어 그 위치를 기준으로 한다.
2. 이를 배열의 크기가 1보다 작거나 같을 때까지 반복한다.

병합

1. 두 배열 A, B의 크기를 비교한다. 각 배열의 현재 인덱스를 i, j로 지정한다.
2. i는 A배열의 인덱스, j는 B배열의 인덱스로 사용한다.
3. A[i]와 B[j]를 비교한다. 작은 값을 새로운 배열 C에 저장한다.
4. A[i]가 크면 A[i]를 C에 저장하고 i를 +1 한다. B[j]가 크면 B[j]를 C에 저장하고 j를 +1 한다.
5. 이를 i나 j 둘 중 하나가 각 배열의 끝에 도달할 때까지 반복한다.
6. 끝까지 저장 못한 배열의 값을 순서대로 C에 저장한다.
7. C 배열을 윈래의 배열에 저장한다.



이 정렬 알고리즘은 분할 과정과 병합 과정으로 나뉘어진다.

병합 과정의 경우 두 배열 A, B를 정렬하기 때문에 O(nA + nB)와 같다.

A, B 배열은 하나의 배열을 나눈 것이기 때문에 nA + nB = n이다.

따라서 병합 과정에서의 시간 복잡도는 O(n)이다.

분할 과정의 경우 크기가 n인 배열을 크기가 1이 될 때까지 반으로 나누기 때문에 시간 복잡도는 O(logn)이다.

각 분할별로 병합을 진행하므로 병합 정렬의 시간 복잡도는 **O(nlogn)**이다.

정렬을 위한 C 배열을 하나 더 생성하므로 공간 복잡도는 O(2n)이다.

```c++
void merge(vector<int> v, int s, int e, int m) {
    vector<int> ret;
    int i = s, j = m + 1, c = 0;
    
    while(i<=m && j<=e) {
        if(v[i] < v[j]) {
            ret.push_back(v[i++]);
        } else {
            ret.push_back(v[j++]);
        }
    }
    
    while(i<=m) ret.push_back(v[i++]);
    while(j<=e) ret.push_back(v[j++]);
    
    for(int k=s; k<=e; k++) {
        v[k] = ret[c++];
    }
}

void mergeSort(vector<int> v, int s, int e) {
    if(s<e) {
        int m = (s + e) / 2;
        mergeSort(v, s, m);
        mergeSort(v, m+1, e);
        
        merge(v, s, e, m);
    }
}
```



## 5. 퀵 정렬(Quick Sort)

> 분할 정복(Divide and Conquer)방식의 알고리즘
>
> pivot point라는 기준값을 설정하고 이 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 옮기는 방식

1. pivot point로 배열의 값 하나를 정한다. 보통 맨 앞이나 맨 뒤, 중간 값이나 랜덤 값으로 정한다.
2. 비교를 진행하기 위해 가장 왼쪽 배열의 인덱스를 left, 가장 오른쪽 배열의 인덱스를 right로 한다.
3. right부터 비교를 진행한다. right가 left보다 클 때만 반복하며 비교한 배열 값이 pivot point보다 크면 right를 하나 감소시키고 비교를 반복한다.
4. pivot point보다 작은 배열 값을 찾으면 반복을 중지한다.
5. left부터 비교를 진행한다. right가 left보다 클 때만 반복하며 비교한 배열 값이 pivot point보다 작으면 left를 하나 증가시키고 비교를 반복한다.
6. pivot point보다 큰 배열 값을 찾으면 반복을 중지한다.
7. left 인덱스의 값과 right 인덱스의 값을 바꾼다.
8. 3, 4, 5, 6, 7의 과정을 left < right일 경우 계속 반복한다.
9. left의 값과 pivot point를 바꾼다.
10. 맨 왼쪽부터 left-1까지, left+1부터 맨 오른쪽까지로 나눠 위 과정을 반복한다.



퀵 정렬은 분할과 동시에 정렬을 진행한다.

각 정렬은 배열의 크기 n 만큼 비교하며 이를 총 분할 깊이인 logn 만큼 진행하므로 시간 복잡도는 **O(nlogn)**이다.

다만 최악의 경우(배열이 이미 정렬된 경우) 분할이 n 만큼 일어나므로 시간 복잡도는 **O(n^2)**이다.

이를 방지하기 위해 pivot point를 중간값이나 랜덤값으로 정하기도 한다.

최악의 경우 때문에 병합 정렬보다 느린 알고리즘이라 생각할 수 있지만 일반적으로 퀵 정렬이 병합 정렬보다 20% 이상 빠르다고 한다.

```c++
void quickSort(vector<int> v, int s, int e) {
    int pivot = v[s];
    int bs = s, be = e;
    while(s<e) {
        while(pivot<=v[e] && s<e) e--;
        if(s>e) break;
        while(pivot>=v[s] && s<e) s++;
        if(s>e) break;
        swap(v[s], v[e]);
    }
    swap(v[bs], v[s]);
    if(bs<s) quickSort(v, bs, s-1);
    if(be>e) quickSort(v, s+1, be);
}
```



## 6. 카운팅 정렬(Counting Sort)

> 정렬하고자 하는 배열의 모든 요소값의 빈도를 세어 정렬하는 방법

1. 정렬하고자 하는 배열 A를 순회하며 모든 요소값의 빈도를 배열 C에 저장한다.
2. 배열 C를 순회하며 누적합을 구한다. C[n] = C[n] + C[n-1]
3. 배열 A와 같은 크기의 배열 B를 생성한다.
4. 배열 A를 역순으로 순회하며 요소값을 인덱스로 가지는 배열 C의 값을 찾는다. 이를 인덱스로 가지는 배열 B에 저장한다. B[C[A[n]]] = A[n]
5. 배열 C의 해당 인덱스의 요소값을 -1 하며 반복한다.



정렬하고자 하는 배열의 크기가 n이면 이를 순회하며 카운팅 배열을 만드는 시간 복잡도는 O(n)이다.

카운팅 배열의 크기가 k이면 카운팅 배열의 공간 복잡도는 O(k)이며, 이를 순회하며 누적합을 구하는 시간 복잡도 역시 O(k)이다.

따라서 정렬 알고리즘의 시간 복잡도는 **O(n+k)**이다.

여기서 카운팅 배열의 크기 k는 정렬하고자 하는 배열의 요소값 중 최대값을 가리킨다.

따라서 카운팅 정렬은 최대값이 클 수록 시간 복잡도는 커지며 비효율적이다.

```c++
void countingSort(vector<int> v, int max_num) {
    int B[v.size()], C[max_num + 1];
    for(int i=0; i<v.size(); i++) {
        C[v[i]]++;
    }
    for(int i=1; i<=max_num; i++) {
        C[i] += C[i-1];
    }
    for(int i=v.size()-1; i>=0; i--) {
        B[C[v[i]] - 1] = v[i];
        C[v[i]]--;
    }
}
```



### 퀵 정렬이 병합 정렬보다 빠른 이유

보통 퀵 정렬과 병합 정렬 알고리즘은 재귀 함수로 작성한다. 

퀵 정렬의 경우 정렬하고자 하는 배열 하나에서 pivot과 인덱스를 통한 정렬을 수행한다. 그러나 병합 정렬의 경우 분할한 후 병합하는 과정마다 새로운 배열을 계속 생성해야 한다. 따라서 이 때 발생하는 시간 지연이 생기게 되어 퀵 정렬이 병합 정렬보다 빠르다.

퀵 정렬의 경우 pivot과 그 주변의 원소들을 비교하여 교환하는 횟수가 많다. 따라서 병합 정렬보다 캐시 적중률이 높아 원소에 접근하는 속도가 빠르기 때문에 병합 정렬보다 평균적으로 20% 이상 빠르다.