# 06. 동적 계획법(Dynamic Programming)

#### 메모이제이션(Memoization)

> 부분 문제에 대한 결과 값을 메모리에 저장하여 동일한 문제를 다시 계산하지 않도록 하는 기법
>
> 동적 계획법의 핵심

메모이제이션을 이용하면 부분 문제의 답을 메모리에 저장해야하기 때문에 추가적인 메모리가  필요하다.

재귀 함수 호출로 인해 시스템 호출 스택을 사용하게 되어 실행 속도가 저하되거나 오버플로우가 발생할 수 있다.

#### 동적 계획(Dynamic Programming) 알고리즘

> 최적화 문제를 해결하는 알고리즘
>
> 최적화 문제: 최적(최대값이나 최소값 등)값을 구하는 문제

작은 부분 문제들의 해들을 구하고 이를 이용하여 보다 큰 부분 문제를 해결하여 최종 문제를 해결하는 방법

- 완전검색을 좀 더 효율적으로 하는 방법
- 재귀 + 메모이제이션(여기서 재귀는 문제를 재귀적으로 정의하는 것)
- 점화식을 찾으면 가능

동적 계획법 적용 요건

* 중복 부분문제 구조(Overlapping Subproblems)
  * 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 문제들의 최적해를 이용하여 순환적으로 큰 문제 해결
  * 이전에 계산되어졌던 작은 문제의 해가 더 큰 문제의 해를 구할 때 중복해서 사용
  * 이미 해결된 작은 문제들의 해를 메모리에 저장(메모이제이션)
* 최적 부분문제 구조(Optimal Substructure)
  * 동적 계획법은 최적화의 원칙(Principle of Optimality)을 만족하는 문제에 적용 가능
  * 최적화의 원칙
    * 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 함
    * DP 방법 자체가 큰 문제의 최적해를 작은 문제의 최적해들을 이용하여 구함
    * 큰 문제의 최적해가 작은 문제의 최적해들로 구성되지 않으면 DP를 사용할 수 없음

#### 분할 정복 vs 동적 계획법

분할 정복

- 큰 문제를 작은 부분 문제들로 분할
- 부분 문제를 재귀적으로 해결
- 부분 문제의 해를 결합
- 부분 문제의 해가 중복 사용되지 않는다.

동적 계획법

- 부분 문제들의 해는 더 작은 부분 문제들의 해를 공유
- 모든 부분 문제를 한 번만 계산하고 결과를 저장하여 재사용

```python
m = [0] * (n + 1)
m[0] = 0
m[1] = 1
# 메모이제이션을 이용한 피보나치 수열 함수
def fibo(n):
    if n >= 2 and m[n] == 0:
        m[n] = fibo(n - 1) + fibo(n - 2)
    return m[n]


# DP를 이용한 피보나치 수열 함수
def fibo_dp(n):
    for i in range(2, n + 1):
        m[i] = m[i - 1] + m[i - 2]
    return m[n]
```

동적 계획법은 반복문을 사용하기 때문에 함수 호출이 발생하지 않는다.

메모이제이션이나 분할 정복의 경우 하향식 방법(Top-Down)

동적 계획법의 경우 상향식 방법(Bottom-Up)