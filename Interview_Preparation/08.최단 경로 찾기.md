# 08. 최단 경로 찾기

최단 경로(Shortest Path)는 정점과 정점을 연결하는 경로 중 간선들의 가중치의 합이 최소가 되는 경로이다.

그래프에서 정점끼리의 최단 경로를 구하는 문제는 여러 종류가 있다.

- 하나의 정점에서 다른 하나의 정점까지의 최단 경로
- 하나의 정점에서 다른 모든 정점까지의 최단 경로
- 하나의 정점까지 도달하는 모든 최단 경로
- 모든 최단 경로

## 1. 다익스트라(Dijkstra) 알고리즘

> 하나의 정점에서 다른 모든 정점까지의 최단 경로를 구하는 알고리즘 기법
>
> 첫 정점을 기준으로 연결되어 있는 정점들을 추가하며 최단 거리를 갱신한다.
>
> 그리디 기법을 적용한 알고리즘

1. 주어진 그래프를 인접 행렬로 구성한다.(자기 자신에 대한 가중치는 0, 인접하지 않은 정점의 가중치는 무한대)(`m`)
2. 시작 정점에서 모든 점까지의 거리를 `d` 배열에 초기화한다.(`a`)
3. 시작 정점을 방문한다.
4. 방문하지 않은 정점 중 `d`의 거리가 가장 짧은 정점을 선택한다.(`v`)
5. 해당 정점을 방문한다.
6. 해당 정점에서 방문하지 않은 인접 정점을 찾는다.(`w`)
7. `a`에서 `w`로 가는 거리(`d[w]`)와 `a`에서 `v`를 거쳐 `w`로 가는 거리(`d[v]` + `m[v][w]`)를 비교하여 작은 값을 `d`에 갱신한다.
8. 모든 정점을 방문할 때까지 4~7을 반복한다.

```python
def dijkstra(a):
    global INF, N
    visited[a] = 1

    for i in range(N):
        d[i] = m[a][i]

    while sum(visited) != N:
        min_val = INF
        min_node = 0
        for i in range(N):
            if not visited[i] and d[i] < min_val:
                min_val = d[i]
                min_node = i

        visited[min_node] = 1
        for i in range(N):
            if 0 < m[min_node][i] < INF:
                d[i] = min(d[i], d[min_node] + m[min_node][i])

    return d
```



특징

- 다익스트라 알고리즘은 간선이 음의 가중치를 가질 때 사용할 수 없다.
  - 다익스트라는 한 번 경로를 확정한 정점은 다시 갱신하지 않는다.
  - 즉, 방문 정점을 결정하는 순간 그 경로까지의 최단 거리가 보장되어야 한다.
  - 따라서 음의 가중치로 인해 갱신이 될 수 있는 경우에는 사용할 수 없다.
- 시간 복잡도는 정점 방문에 n, 최단 경로 확정에 n이므로 **O(n^2)**이다.



## 2. 플로이드-워셜(Floyd-Warshall) 알고리즘

> 모든 정점의 모든 최단 경로를 구하는 알고리즘 기법
>
> 동적 계획법을 적용한 알고리즘

모든 정점에 대하여 다익스트라를 적용하면 모든 정점의 최단 경로를 구할 수 있다.

다만 이 경우에는 다익스트라의 특징상 음의 가중치를 적용할 수 없다.

플로이드 워셜은 간선이 음의 가중치를 가지고 있어도 모든 정점의 최단 경로를 구할 수 있다.

또한, 다익스트라보다 구현이 간단하다.

1. 세 개의 정점 i, j, k가 있는 경우 i에서 j로 가는 최단 경로는 i->j와 i->k->j 경로 중 작은 값이다.
2. 경유 가능한 점을 하나씩 추가하며 최단 경로를 구한다.
3. 결국 모든 점을 경유 가능한 점들로 고려하면서 모든 쌍의 최단 경로를 계산한다.

```python
def floyd_warshall():
    global N
    for k in range(N):
        for i in range(N):
            if i != k:
                for j in range(N):
                    if j != k and j != i:
                        d[i][j] = min(d[i][j], d[i][k] + d[k][j])
    return d
```



경유 가능한 모든 정점을 고려하는 데 n, 시작 정점이 n, 도착 정점이 n개이므로 총 시간 복잡도는 **O(n^3)**이다.