# Divide and Conquer & Backtracking

* 문제를 분할해서 해결하는 분할 정복(Divide and Conquer) 기법을 이해하고 대표적인 알고리즘인 퀵 정렬과 병합 정렬에 대해 학습한다.
* 상태 공간 트리의 모든 노드를 검색하는 백트래킹에 대해 학습한다.
* 이진 트리(Binary Tree)의 특성을 이해하고 이진 트리의 중요한 연산인 탐색, 삽입, 삭제 알고리즘을 학습한다.



## 분할 정복

### 1. 설계 전략

* 분할(Divide)
  * 해결할 문제를 여러 개의 작은 부분으로 나눈다.
* 정복(Conquer)
  * 나눈 작은 문제를 각각 해결한다.
* 통합(Combine)
  * (필요하다면) 해결된 해답을 모은다.



### 2. 병합 정렬(Merge Sort)

* 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
* 분할 정복 알고리즘 활용
  * 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
  * top-down 방식
* 시간복잡도
  * O(nlogn)
* 병합 정렬 과정
  * 분할 단계 : 전체 자료 집합에 대하여 최소 크기의 부분집합이 될 때까지 분할 작업을 계속한다.
  * 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합

```python
def merge_sort(a):
    if len(a) <= 1:
        return a

    left = merge_sort(a[:len(a) // 2])
    right = merge_sort(a[len(a) // 2:])
    return merge(left, right)

def merge(left, right):
    i, j, k = 0, 0, 0
    l, r = len(left), len(right)
    result = [0] * (l + r)
    while i < l and j < r:
        if left[i] > right[j]:
            result[k] = right[j]
            j += 1
        else:
            result[k] = left[i]
            i += 1
        k += 1

    while i < l:
        result[k] = left[i]
        k += 1
        i += 1
    while j < r:
        result[k] = right[j]
        k += 1
        i += 1
    return result
```



### 3. 퀵 정렬(Quick Sort)

* 주어진 배열울 두 개로 분할하고, 각각을 정렬한다.
* 병합 정렬과 다른 점
  * 병합 정렬은 그냥 두 부분으로 나누는 반면에 퀵 정렬은 분할할 때 기준 아이템(pivot item) 중심으로 이보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다.
  * 각 부분 정렬이 끝난 후 병합 정렬은 병합이라는 후처리 작업이 필요하지만 퀵 정렬은 필요하지 않다.

```python
def quick_sort(a, l, r):
    if l < r:
        s = partition(a, l, r)
        quick_sort(a, l, s - 1)
        quick_sort(a, s + 1, r)


def partition(a, l, r):
    p = a[l]
    i, j = l, r
    while i <= j:
        while i < len(a) and a[i] <= p:
            i += 1
        while j < len(a) and a[j] > p:
            j -= 1
        if i < j:
            a[i], a[j] = a[j], a[i]

    a[l], a[j] = a[j], a[l]
    return j
```



### 4. 이진 검색(Binary Search)

* 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
  * 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함
* 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.
* 검색 과정
  * 자료의 중앙에 있는 원소를 고른다.
  * 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.
  * 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행한다.
  * 찾고자 하는 값을 찾을 때까지 위의 과정을 반복한다.

```python
def binary_search(a, start, end, key):
    if start > end:
        return -1
    mid = (start + end) // 2
    if a[mid] == key:
        return mid
    elif a[mid] > key:
        return binary_search(a, start, mid - 1, key)
    else:
        return binary_search(a, mid + 1, end, key)
```



## 백트래킹(Backtracking)

### 1. 개념

* 여러 가지 선택지(옵션)들이 존재하는 상황에서 한 가지를 선택한다.
* 선택이 이루어지면 새로운 선택지들의 집합이 생성된다.
* 이런 선택을 반복하면서 최종 상태에 도달한다.
  * 올바른 선택을 계속하면 목표 상태(goal state)에 도달한다.



### 2. 백트래킹과 깊이 우선 탐색과의 차이

* 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임(**Pruning** 가지치기)
* 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단
* 깊이 우선 탐색을 가하기에는 경우의 수가 너무 많다. 즉, N! 가지의 경우의 수를 가진 문제에 대해 깊이 우선 탐색을 가하면 당연히 처리 불가능한 문제
* 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수 함수 시간(Exponential Time)을 요하므로 처리 불가능



### 3. 백트래킹 기법

* 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면 그 노드의 부모로 되돌아가(backtracking) 다음 자식 노드로 감
* 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 하며, 반대로 해답의 가능성이 있으면 유망하다고 한다.
* 가지치기(pruning) : 유망하지 않는 노드가 포함되는 경로는 더 이상 고려하지 않는다.



## 트리

* 트리는 싸이클이 없는 무방향 연결 그래프이다.
  * 두 노드(or 정점) 사이에는 유일한 경로가 존재한다.
  * 각 노드는 최대 하나의 부모 노드가 존재할 수 있다.
  * 각 노드는 자식 노드가 없거나 하나 이상이 존재할 수 있다.
* 비선형 구조
  * 원소들 간에 1:n 관계를 가지는 자료구조
  * 원소들 간에 계층관계를 가지는 계층형 자료구조
* 한 개 이상의 노드로 이루어진 유한 집합이며 다음 조건을 만족한다.
  * 노드 중 부모가 없는 노드를 루트(root)라 한다.
  * 나머지 노드들은 n(>=0)개의 분리 집합 T1, ..., TN으로 분리될 수 있다.
  * 이들 T1, ..., TN은 각각 하나의 트리가 되며(재귀적 정의) 루트의 서브 트리(subtree)라 한다.



### 1. 용어

* 노드(node)
  * 트리의 원소이고 정점(vertex)이라고도 한다.
* 간선(edge)
  * 노드를 연결하는 선
  * 부모와 자식 노드를 연결
* 루트 노드(root node)
  * 트리의 시작 노드
* 형제 노드(sibling node)
  * 같은 부모 노드의 자식 노드들
* 조상 노드
  * 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
* 서브 트리(subtree)
  * 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
* 자손 노드
  * 서브 트리에 있는 하위 레벨의 노드들



### 2. 이진 트리(Binary Tree)

* 모든 노드들이 최대 2개의 서브 트리를 갖는 특별한 형태의 트리
* 각 노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리

#### 특성

* 레벨 i에서의 노드의 최대 개수는 2^i개
* 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h + 1)개가 되며, 최대 개수는 (2^(h + 1) - 1)개가 된다.

#### 포화 이진 트리(Full Binary Tree)

* 모든 레벨에 노드가 포화상태로 채워져 있는 이진 트리
* 높이가 h일 때, 최대의 노드 개수인 (2^(h + 1) - 1)개의 노드를 가진 이진 트리

#### 완전 이진 트리(Complete Binary Tree)

* 높이가 h이고 노드 수가 n개일 때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리

#### 편향 이진 트리(Skewed Binary Tree)

* 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리



### 3. 순회

* 트리의 노드들을 체계적으로 방문하는 것

#### 전위 순회(preorder traversal) : VLR

* 자손 노드보다 현재 노드를 먼저 방문한다.

#### 중위 순회(inorder traversal) : LVR

* 왼쪽 자손 노드, 현재 노드, 오른쪽 자손 노드 순으로 방문한다.

#### 후위 순회(postorder traversal) : LRV

* 현재 노드보다 자손 노드를 먼저 방문한다.