# Start

## SW 문제 해결

### 1. SW 문제 해결 역량

* 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
* 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 연결하여 큰 그림을 만드는 능력
* 문제 해결 역량은 추상적인 기술이다.
  * 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없다.
  * 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않는다.
* 문제 해결 역량을 향상시키기 위해서 훈련이 필요하다.



### 2. 문제 해결 과정

* 문제를 읽고 이해한다.
* 문제를 익숙한 용어로 재정의한다.
* 어떻게 해결할지 계획을 세운다.
* 계획을 검증한다.
* 프로그램으로 구현한다.
* 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.



## 복잡도 분석

### 1. 알고리즘?

* 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
* 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.



### 2. 알고리즘의 효율

* 공간적 효율성과 시간적 효율성
  * 공간적 효율성 : 연산량 대비 얼마나 적은 메모리 공간을 요하는가
  * 시간적 효율성 : 연산량 대비 얼마나 적은 시간을 요하는가
  * 효율성을 뒤집어 표현하면 복잡도(Complexity)가 된다. 복잡도가 높을 수록 효율성은 저하된다.
* 시간 복잡도 분석
  * 하드웨어 환경에 따라 처리시간이 달라진다.
  * 소프트웨어 환경에 따라 처리시간이 달라진다.
  * 이러한 환경적 차이로 인해 분석이 어렵다.



### 3. 복잡도의 점근적 표기

* 시간 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 다항식이다.
* 이를 단순한 함수로 표현하기 위해 점근적 표기(Asymptotic Notation)를 사용한다.
* 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.
  * Big-Oh 표기
  * Big-Omega 표기
  * Big-Theta 표기

#### Big-Oh 표기

* 복잡도의 점근적 상한을 나타낸다.
* 복잡도가 `f(n) = 2n^2 - 7n + 4` 라면, f(n)의 O-표기는 O(n^2)이다.

#### 자주 사용하는 O-표기

* O(1) - 상수 시간(Constant time) : 해쉬
* O(logn) - 로그(대수) 시간(Logarithmic time) : 이진 검색
* O(n) - 선형 시간(Linear time) : 순차 검색
* O(nlogn) - 로그 선형 시간(Log-linear time) : 퀵, 병합, 힙 정렬
* O(n^2) - 제곱 시간(Quadratic time) : 버블, 삽입, 선택 정렬, 다익스트라(Dijkstra)
* O(n^3) - 세제곱 시간(Cubic time) : 플로이드-워셜(DP, 그래프)
* O(2^n) - 지수 시간(Exponential time) : 부분 집합(배낭 문제)
* O(n!) - 계승 시간(Factorial time) : 순열(TSP)



### 4. 왜 효율적인 알고리즘이 필요한가

* 10억 개의 숫자를 정렬하는데 PC에서 O(n^2) 알고리즘은 300여 년이 걸리는 반면에 O(nlogn) 알고리즘은 5분만에 정렬한다.(근사적으로 100만번의 연산을 하는 데 걸리는 시간은 1초)
* 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.
* 값 비싼 HW 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.



## 표준 입출력 방법(python)

### 1. python3 표준 입출력

* 입력
  * Raw 값의 입력 : input() - 받은 입력값을 문자열로 취급
* 출력
  * print() - 표준 출력 함수. 출력값의 마지막에 개행 문자 포함
  * print("text", end='') - 출력 시 마지막에 개행 문자 제외
  * print("%d" % number) - formatting 된 출력



### 2. 파일의 내용을 표준 입력으로 읽어오는 방법

```python
import sys
sys.stdin = open('input.txt', 'r')
sys.stdout = open('output.txt', 'w')

text = input()
print(text)
```





## 비트 연산

### 1. 비트 연산자

* `&` : 비트단위로 AND 연산을 한다.
* `|`  : 비트단위로 OR 연산을 한다.
* `^` : 비트단위로 XOR 연산을 한다.(같으면 0, 다르면 1)
* `~` : 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.(NOT)
* `<<` : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
* `>>` : 피연산자의 비트 열을 오른쪽으로 이동시킨다.

```python
# 비트 연산 예제
def Bbit_print(i):
	output = ""
	for j in range(7, -1, -1):
		output += "1" if i & (1 << j) else "0"
	print(output)
	
for i in range(-5, 6):
	print("%3d = " % i, end='')
	Bbit_print(i)
```



### 2. 엔디안(Endianness)

* 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법. HW 아키텍처마다 다르다.
* 주의 - 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바로 이해하지 않으면 오류를 발생시킬 수 있다.
* 엔디안은 크게 두 가지로 나뉨
  * 빅 엔디안(Big-endian) - 보통 큰 단위가 앞에 나옴(네트워크)
  * 리틀 엔디안(Little-endian) - 작은 단위가 앞에 나옴(대다수 데스크탑)



## 진수

### 1. 컴퓨터에서의 음의 정수 표현 방법

* 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환한다.
* 2의 보수 : 1의 보수 방법으로 표현된 값의 최하위 비트에 1을 더한다.



## 실수

### 1. 실수의 표현

* 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용한다.
* 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다.
  * 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현
  * `1001.0011` => `1.0010011 * 2^3`



### 2. 실수를 저장하기 위한 형식

* 단정도 실수(32비트)
  * 부호 1비트, 지수 8비트, 가수 23비트
* 배정도 실수(64비트)
  * 부호 1비트, 지수 11비트, 가수 52비트
* 가수부(mantissa) : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
* 지수부(exponent) : 실제 소수점의 위치를 지수 승으로 표현한 것



### 3. 컴퓨터에서의 실수

* 컴퓨터는 실수를 근사적으로 표현한다.
  * 이진법으로 표현할 수 없는 형태의 실수는 근사값으로 저장되는데, 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.
* 실수 자료형의 유효 자릿수를 알아두자.
  * 32비트 실수형 유효자릿수(십진수) : 6
  * 64비트 실수형 유효자릿수(십진수) : 15
* 파이썬에서의 실수 표현 범위를 알아보자.
  * 파이썬에서는 내부적으로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다.
  * 최대로 표현할 수 있는 값은 약 1.8 * 10^308 이고 이 이상은 inf로 표현
  * 최소로 표현할 수 있는 값은 약 5.0 * 10^-324 이고 이 이하는 0으로 표현